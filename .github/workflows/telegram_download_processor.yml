name: Telegram Video Download and Processor

on:
  workflow_dispatch:
    inputs:
      encoded_file_info:
        description: 'Base64 encoded Telegram file info'
        required: true
        type: string
      file_hash:
        description: 'File hash for metadata'
        required: true
        type: string
      playback_speed:
        description: 'Desired playback speed'
        required: true
        type: number
        default: 1.5
      split_timestamps:
        description: 'Comma-separated timestamps for splitting (HH:MM:SS)'
        required: false
        type: string
        default: ''
      release_name:
        description: 'Release Name'
        required: true
        type: string
      video_title:
        description: 'Title for the YouTube Video'
        required: true
        type: string

permissions:
  contents: write

jobs:
  download-and-process:
    runs-on: ubuntu-latest-16core
    timeout-minutes: 360

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Install required packages
      run: |
        sudo apt-get update
        sudo apt-get install -y ffmpeg wget bc jq curl python3-pip

    - name: Install Python dependencies
      run: |
        python3 -m pip install --upgrade pip
        pip install telethon requests google-api-python-client google-auth-httplib2 google-auth-oauthlib

    - name: Decode file information
      run: |
        echo "${{ github.event.inputs.encoded_file_info }}" > encoded.txt
        python3 -c "
        import base64, json, sys
        encoded = open('encoded.txt').read().strip()
        decoded = base64.urlsafe_b64decode(encoded + '=' * (4 - len(encoded) % 4))
        file_info = json.loads(decoded)
        print('File ID:', file_info['id'])
        print('Size:', file_info['size'])
        print('DC ID:', file_info['dc_id'])
        with open('file_info.json', 'w') as f:
            json.dump(file_info, f, indent=2)
        "
        
        echo "FILE_INFO_JSON=$(cat file_info.json | jq -c .)" >> $GITHUB_ENV

    - name: Create Telethon download script
      run: |
        cat > download_telegram.py << 'EOF'
        import asyncio
        import sys
        import json
        from telethon.sessions import StringSession
        from telethon import TelegramClient
        import os
        
        async def main():
            # Read file info
            with open('file_info.json', 'r') as f:
                file_info = json.load(f)
            
            # Get Telegram credentials from environment
            api_id = int(os.getenv('TELEGRAM_API_ID', '123456'))
            api_hash = os.getenv('TELEGRAM_API_HASH', '')
            session_string = os.getenv('TELEGRAM_SESSION_STRING', '')
            
            if not all([api_id, api_hash, session_string]):
                print("âŒ Missing Telegram credentials in workflow")
                sys.exit(1)
            
            # Create client
            client = TelegramClient(
                StringSession(session_string),
                api_id,
                api_hash
            )
            
            await client.start()
            
            try:
                # Construct InputDocument
                from telethon.tl.types import InputDocument
                from telethon.tl.functions.upload import GetFileRequest
                from telethon.tl.types import InputDocumentFileLocation
                
                # Create document location
                doc = InputDocument(
                    id=file_info['id'],
                    access_hash=file_info['access_hash'],
                    file_reference=bytes.fromhex(file_info['file_reference']) if file_info['file_reference'] else b''
                )
                
                # Download the file
                filename = file_info['file_name'] or 'video.mp4'
                print(f"ðŸ“¥ Downloading {filename} ({file_info['size']} bytes)...")
                
                # Use download_media which handles chunking
                import time
                start_time = time.time()
                
                def progress_callback(current, total):
                    percent = (current / total) * 100
                    mb_current = current / (1024*1024)
                    mb_total = total / (1024*1024)
                    elapsed = time.time() - start_time
                    if elapsed > 0:
                        speed = mb_current / elapsed
                        eta = (mb_total - mb_current) / speed if speed > 0 else 0
                        print(f"\rProgress: {percent:.1f}% ({mb_current:.1f}/{mb_total:.1f} MB) | Speed: {speed:.1f} MB/s | ETA: {eta:.0f}s", end='')
                
                downloaded = await client.download_media(
                    doc,
                    file=filename,
                    progress_callback=progress_callback
                )
                
                print(f"\nâœ… Download complete: {downloaded}")
                
                # Verify file size
                import os
                actual_size = os.path.getsize(filename)
                expected_size = file_info['size']
                
                if actual_size == expected_size:
                    print(f"âœ… Size verified: {actual_size} bytes")
                else:
                    print(f"âš ï¸ Size mismatch: expected {expected_size}, got {actual_size}")
                
            finally:
                await client.disconnect()
        
        if __name__ == '__main__':
            asyncio.run(main())
        EOF

    - name: Download from Telegram using Telethon
      env:
        TELEGRAM_API_ID: ${{ secrets.TELEGRAM_API_ID }}
        TELEGRAM_API_HASH: ${{ secrets.TELEGRAM_API_HASH }}
        TELEGRAM_SESSION_STRING: ${{ secrets.TELEGRAM_SESSION_STRING }}
      run: |
        python3 download_telegram.py
        
        # Check if download succeeded
        if [ -f "video.mp4" ] || [ -f "$(ls *.mp4 2>/dev/null | head -1)" ]; then
          MP4_FILE=$(ls *.mp4 2>/dev/null | head -1)
          echo "VIDEO_FILE=$MP4_FILE" >> $GITHUB_ENV
          echo "âœ… Downloaded: $MP4_FILE"
          echo "ðŸ“Š Size: $(ls -lh "$MP4_FILE" | awk '{print $5}')"
        else
          echo "âŒ No video file found after download"
          exit 1
        fi

    - name: Process video (same as before)
      run: |
        # Extract filename without extension
        BASENAME="${VIDEO_FILE%.*}"
        echo "BASE_FILENAME=$BASENAME" >> $GITHUB_ENV
        
        # Get video duration
        DURATION=$(ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 "$VIDEO_FILE" | cut -d'.' -f1)
        echo "TOTAL_DURATION=$DURATION" >> $GITHUB_ENV
        
        # Prepare split points
        if [ -z "${{ github.event.inputs.split_timestamps }}" ]; then
          echo "SPLIT_POINTS=0,$DURATION" >> $GITHUB_ENV
          echo "PART_COUNT=1" >> $GITHUB_ENV
        else
          # Convert timestamps to seconds
          IFS=',' read -ra TIMESTAMPS <<< "${{ github.event.inputs.split_timestamps }}"
          SPLIT_POINTS="0"
          for timestamp in "${TIMESTAMPS[@]}"; do
            IFS=':' read -ra TIME <<< "$timestamp"
            HOURS=${TIME[0]:-0}
            MINUTES=${TIME[1]:-0}
            SECONDS=${TIME[2]:-0}
            TOTAL_SECONDS=$((HOURS * 3600 + MINUTES * 60 + SECONDS))
            SPLIT_POINTS="$SPLIT_POINTS,$TOTAL_SECONDS"
          done
          SPLIT_POINTS="$SPLIT_POINTS,$DURATION"
          echo "SPLIT_POINTS=$SPLIT_POINTS" >> $GITHUB_ENV
        fi
        
        # Split video
        IFS=',' read -ra POINTS <<< "$SPLIT_POINTS"
        PART_COUNT=0
        
        for i in $(seq 0 $((${#POINTS[@]} - 2))); do
          START=${POINTS[i]}
          END=${POINTS[i+1]}
          
          if (( $(echo "$END > $START" | bc -l) )); then
            PART_COUNT=$((PART_COUNT + 1))
            OUTPUT_FILE="${BASENAME}_part${PART_COUNT}.mp4"
            
            echo "Splitting part $PART_COUNT: $START to $END seconds"
            ffmpeg -i "$VIDEO_FILE" -ss "$START" -to "$END" -c copy "$OUTPUT_FILE"
          fi
        done
        
        echo "PART_COUNT=$PART_COUNT" >> $GITHUB_ENV

    - name: Apply speed adjustment
      run: |
        SPEED=${{ github.event.inputs.playback_speed }}
        
        for i in $(seq 1 $PART_COUNT); do
          INPUT_FILE="${BASE_FILENAME}_part${i}.mp4"
          OUTPUT_FILE="${BASE_FILENAME}_part${i}_${SPEED}x.mp4"
          
          echo "Processing part $i at ${SPEED}x"
          
          # Calculate audio filter
          if (( $(echo "$SPEED > 2.0" | bc -l) )); then
            ATEMPO_FILTERS=""
            TEMP_SPEED=$SPEED
            while (( $(echo "$TEMP_SPEED > 2.0" | bc -l) )); do
              ATEMPO_FILTERS="${ATEMPO_FILTERS}atempo=2.0,"
              TEMP_SPEED=$(echo "scale=2; $TEMP_SPEED / 2.0" | bc)
            done
            ATEMPO_FILTERS="${ATEMPO_FILTERS}atempo=$TEMP_SPEED"
          elif (( $(echo "$SPEED < 0.5" | bc -l) )); then
            ATEMPO_FILTERS=""
            TEMP_SPEED=$SPEED
            while (( $(echo "$TEMP_SPEED < 0.5" | bc -l) )); do
              ATEMPO_FILTERS="${ATEMPO_FILTERS}atempo=0.5,"
              TEMP_SPEED=$(echo "scale=2; $TEMP_SPEED * 2.0" | bc)
            done
            ATEMPO_FILTERS="${ATEMPO_FILTERS}atempo=$TEMP_SPEED"
          else
            ATEMPO_FILTERS="atempo=$SPEED"
          fi
          
          PTS_FACTOR=$(echo "scale=5; 1 / $SPEED" | bc)
          
          ffmpeg -i "$INPUT_FILE" \
            -filter_complex "[0:v]setpts=${PTS_FACTOR}*PTS[v];[0:a]${ATEMPO_FILTERS}[a]" \
            -map "[v]" -map "[a]" \
            -c:v libx264 -preset medium -crf 23 \
            -c:a aac -b:a 128k \
            -movflags +faststart \
            "$OUTPUT_FILE"
          
          rm -f "$INPUT_FILE"
        done

    - name: Create GitHub Release
      uses: softprops/action-gh-release@v1
      with:
        tag_name: video-${{ github.run_id }}
        name: "${{ github.event.inputs.release_name }}"
        body: |
          Video processed at ${{ github.event.inputs.playback_speed }}x speed
          
          **Details:**
          - YouTube Title: ${{ github.event.inputs.video_title }}
          - Split into ${{ env.PART_COUNT }} parts
          - Downloaded directly from Telegram
        draft: false
        prerelease: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Upload processed parts
      run: |
        for i in $(seq 1 $PART_COUNT); do
          FILE="${BASE_FILENAME}_part${i}_${{ github.event.inputs.playback_speed }}x.mp4"
          echo "Uploading $FILE"
          
          curl -s -X POST \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Content-Type: application/octet-stream" \
            --data-binary @"$FILE" \
            "https://uploads.github.com/repos/${{ github.repository }}/releases/${{ steps.create-release.outputs.id }}/assets?name=$(basename "$FILE")"
        done

        echo "Total $PART_COUNT parts uploaded to GitHub Releases"

    - name: Check YouTube credentials
      id: check_youtube
      run: |
        if [ -n "${{ secrets.YOUTUBE_REFRESH_TOKEN }}" ] && \
           [ -n "${{ secrets.YOUTUBE_CLIENT_ID }}" ] && \
           [ -n "${{ secrets.YOUTUBE_CLIENT_SECRET }}" ]; then
          echo "has_youtube=true" >> $GITHUB_OUTPUT
        else
          echo "has_youtube=false" >> $GITHUB_OUTPUT
          echo "YouTube credentials not set. Skipping YouTube upload."
        fi

    - name: Generate YouTube access token
      if: steps.check_youtube.outputs.has_youtube == 'true'
      run: |
        response=$(curl -s \
          -d "client_id=${{ secrets.YOUTUBE_CLIENT_ID }}" \
          -d "client_secret=${{ secrets.YOUTUBE_CLIENT_SECRET }}" \
          -d "refresh_token=${{ secrets.YOUTUBE_REFRESH_TOKEN }}" \
          -d "grant_type=refresh_token" \
          "https://oauth2.googleapis.com/token")
        
        echo "Response: $response"
        
        access_token=$(echo $response | jq -r '.access_token')
        if [ "$access_token" = "null" ] || [ -z "$access_token" ]; then
          echo "Failed to get access token"
          echo "ACCESS_TOKEN=" >> $GITHUB_ENV
        else
          echo "ACCESS_TOKEN=$access_token" >> $GITHUB_ENV
          echo "Got access token successfully"
        fi

    - name: Upload to YouTube using Python script
      if: steps.check_youtube.outputs.has_youtube == 'true' && env.ACCESS_TOKEN != ''
      run: |
        # Create YouTube upload script
        cat > youtube_upload.py << 'EOF'
        import os
        import sys
        import json
        import google.oauth2.credentials
        import google_auth_oauthlib.flow
        from googleapiclient.discovery import build
        from googleapiclient.errors import HttpError
        from googleapiclient.http import MediaFileUpload
        import argparse

        def upload_video(file_path, title, description, access_token, privacy_status="private"):
            try:
                # Build credentials from access token
                credentials = google.oauth2.credentials.Credentials(access_token)
                
                # Build YouTube API client
                youtube = build('youtube', 'v3', credentials=credentials)
                
                # Create media file upload
                media = MediaFileUpload(
                    file_path,
                    chunksize=-1,
                    resumable=True,
                    mimetype='video/mp4'
                )
                
                # Create request body
                body = {
                    'snippet': {
                        'title': title,
                        'description': description,
                        'tags': ['processed', 'telegram', 'github', 'automated']
                    },
                    'status': {
                        'privacyStatus': privacy_status,
                        'selfDeclaredMadeForKids': False
                    }
                }
                
                # Execute request
                request = youtube.videos().insert(
                    part=','.join(body.keys()),
                    body=body,
                    media_body=media
                )
                
                response = request.execute()
                print(f"âœ… Uploaded video ID: {response['id']}")
                print(f"ðŸ“º Title: {response['snippet']['title']}")
                print(f"ðŸ”— Link: https://youtube.com/watch?v={response['id']}")
                return True
                
            except HttpError as e:
                print(f"âŒ HTTP Error: {e.resp.status} - {e.content}")
                return False
            except Exception as e:
                print(f"âŒ Error: {str(e)}")
                return False

        if __name__ == '__main__':
            parser = argparse.ArgumentParser()
            parser.add_argument('--file', required=True)
            parser.add_argument('--title', required=True)
            parser.add_argument('--description', required=True)
            parser.add_argument('--access_token', required=True)
            parser.add_argument('--privacy', default='private')
            
            args = parser.parse_args()
            
            success = upload_video(
                args.file,
                args.title,
                args.description,
                args.access_token,
                args.privacy
            )
            
            sys.exit(0 if success else 1)
        EOF
        
        for i in $(seq 1 $PART_COUNT); do
          VIDEO_FILE="${BASE_FILENAME}_part${i}_${{ github.event.inputs.playback_speed }}x.mp4"
          
          if [ $PART_COUNT -eq 1 ]; then
            TITLE="${{ github.event.inputs.video_title }}"
            DESCRIPTION="Processed at ${{ github.event.inputs.playback_speed }}x speed\nUploaded via GitHub Actions workflow"
          else
            TITLE="${{ github.event.inputs.video_title }} - Part $i of $PART_COUNT"
            DESCRIPTION="Processed at ${{ github.event.inputs.playback_speed }}x speed\nPart $i of $PART_COUNT\nUploaded via GitHub Actions workflow"
          fi
      
          echo "ðŸ“¤ Uploading part $i to YouTube..."
          echo "ðŸ“ File: $VIDEO_FILE"
          echo "ðŸ“º Title: $TITLE"
      
          python3 youtube_upload.py \
            --file "$VIDEO_FILE" \
            --title "$TITLE" \
            --description "$DESCRIPTION" \
            --access_token "$ACCESS_TOKEN" \
            --privacy "private"
        done
        
        echo "âœ… YouTube upload completed for $PART_COUNT parts"
        
    - name: Final cleanup
      run: |
        # Clean up all processed files
        rm -f "$ORIGINAL_FILENAME"
        for i in $(seq 1 $PART_COUNT); do
          rm -f "${BASE_FILENAME}_part${i}_${{ github.event.inputs.playback_speed }}x.mp4"
        done
        echo "ðŸ§¹ Cleanup completed"
        
    - name: Send completion notification
      if: always()
      run: |
        echo "ðŸŽ‰ Workflow completed!"
        echo "ðŸ“Š Total parts processed: $PART_COUNT"
        echo "ðŸ“º YouTube upload: ${{ steps.check_youtube.outputs.has_youtube }}"
        echo "ðŸ“ GitHub Release: âœ… Created"
        echo "â±ï¸ Duration: ${{ job.status }}"
